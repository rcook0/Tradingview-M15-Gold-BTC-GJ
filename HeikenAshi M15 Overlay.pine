// @version=5
// M15 Heikin Ashi Overlay Strategy — Fully self-configuring with automatic session detection and symbol-based default volatility factors

strategy("M15 HA Overlay Strategy — Enhanced v1.6",
     overlay=true,
     timeframe="15",
     initial_capital=10000,
     pyramiding=0,
     process_orders_on_close=true,
     calc_on_order_fills=true,
     calc_on_every_tick=false,
     commission_type=strategy.commission.percent,
     commission_value=0.02,
     default_qty_type=strategy.percent_of_equity,
     default_qty_value=10)

//───────────────────────────────
// ⌥ Inputs — General
//───────────────────────────────
symChoice = input.string("Any", "Symbol filter", options=["Any", "Gold (XAU)", "Bitcoin (BTC)", "GBPJPY (GJ)"])
accuracy = input.float(0.70, "Signal accuracy (0..1)", minval=0.30, maxval=1.00, step=0.05)
relax    = 1.0 - accuracy
riskPct  = input.float(10, "Position size % of equity", minval=0.1, maxval=100)

//───────────────────────────────
// ⌥ Automatic session detection
//───────────────────────────────
sessionEnable = input.bool(true, "Enable automatic session detection")
var string sessTZ = syminfo.timezone
var bool inSession = true
if sessionEnable
    h = hour(time, sessTZ)
    m = minute(time, sessTZ)
    inLondon = h >= 7 and h < 12
    inNY     = h >= 13 and h < 17
    inSession := inLondon or inNY

//───────────────────────────────
// ⌥ Adaptive ATR multiplier with symbol-based defaults and manual override
//───────────────────────────────
useManualATR = input.bool(false, "Manual ATR multiplier override")
manualATRMult = input.float(1.0, "Manual ATR multiplier")
atrLen = input.int(14, "ATR length")
atrRaw = ta.atr(atrLen)
volatilityFactor = input.float(1.0, "Volatility sensitivity")

// Symbol-based default factors
defaultATR = switch symChoice
    "Gold (XAU)"    => 1.0
    "Bitcoin (BTC)" => 1.5
    "GBPJPY (GJ)"   => 0.8
    => 1.0

// Adaptive multiplier
atrSMA = ta.sma(atrRaw, 50)
atrAdaptive = atrSMA > 0 ? defaultATR + (atrRaw - atrSMA)/atrSMA * volatilityFactor : defaultATR
atrMultFinal = useManualATR ? manualATRMult : atrAdaptive

//───────────────────────────────
// ⌥ Heikin Ashi, EMA, VWAP, Volume filter
//───────────────────────────────
haSmoothLen = input.int(3, "HA smoothing length")
var float haCloseSmooth = na
haCloseRaw = (open + high + low + close)/4
haCloseSmooth := na(haCloseSmooth[1]) ? haCloseRaw : ta.ema(haCloseRaw, haSmoothLen)
haOpen  = na(haOpen[1]) ? (open + close)/2 : (haOpen[1] + haCloseSmooth[1])/2
haHigh  = math.max(high, math.max(haOpen, haCloseSmooth))
haLow   = math.min(low, math.min(haOpen, haCloseSmooth))

lenEMAfast = input.int(21,  "EMA fast (M15)")
lenEMAslow = input.int(200, "EMA slow (M15)")
emaFast = ta.ema(haCloseSmooth, lenEMAfast)
emaSlow = ta.ema(haCloseSmooth, lenEMAslow)
vwap    = ta.vwap(hlc3)
vwapSlope = vwap - vwap[1]

// Volume filter
useVolumeFilter = input.bool(true, "Enable volume filter")
volLen = input.int(20, "Volume MA length")
volMA  = ta.sma(volume, volLen)
volOK  = not useVolumeFilter or (volume > volMA)

// Confluence zones
bullConfluence = haCloseSmooth > emaSlow and vwapSlope > 0 and volOK
bearConfluence = haCloseSmooth < emaSlow and vwapSlope < 0 and volOK
bgcolor(bullConfluence ? color.new(color.green, 80) : bearConfluence ? color.new(color.red, 80) : na)

// Stochastic
kLen   = input.int(14, "Stoch K length")
dLen   = input.int(3,  "Stoch D length")
smooth = input.int(3,  "Stoch smoothing")
[k, d] = ta.stoch(haCloseSmooth, haHigh, haLow, kLen, smooth, dLen)
obase = 80.0, obMin = 60.0
osbase = 20.0, osMax = 40.0
ob = obase - (obase - obMin) * relax
os = osbase + (osMax - osbase) * relax

// Entry logic with session check
nearTolBase = 0.0, nearTolMax = 5.0
nearTol = nearTolBase + (nearTolMax - nearTolBase) * relax
stochCrossUp   = ta.crossover(k, d) and k < os + nearTol
stochCrossDown = ta.crossunder(k, d) and k > ob - nearTol

bullStructure = haCloseSmooth > vwap and emaFast > emaSlow and vwapSlope > 0 and volOK
bearStructure = haCloseSmooth < vwap and emaFast < emaSlow and vwapSlope < 0 and volOK

longCond  = bullStructure and stochCrossUp and inSession
shortCond = bearStructure and stochCrossDown and inSession

// ATR-based SL/TP using final multiplier
atrPctSL = input.float(1.0, "%ATR for Stop")
atrPctTP = input.float(2.0, "%ATR for Target")
longSL  = haCloseSmooth - atrRaw * atrPctSL * atrMultFinal
longTP  = haCloseSmooth + atrRaw * atrPctTP * atrMultFinal
shortSL = haCloseSmooth + atrRaw * atrPctSL * atrMultFinal
shortTP = haCloseSmooth - atrRaw * atrPctTP * atrMultFinal

// Remaining break-even, trailing, orders, alerts, visuals use previous logic substituting atrMultFinal where needed
